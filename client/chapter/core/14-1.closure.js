
/*


자바스크립트는 함수 지향 언어입니다. 
이런 특징은 개발자에게 많은 자유를 줍니다. 
함수를 동적-? 으로 생성할 수 있고, 
생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 
생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다

.
함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 앞서 학습해서 알고 계실 겁니다.

그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까요? 

함수는 새로운 값을 가져올까요? 아니면 생성 시점 이전의 값을 가져올까요?

매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까요? 
함수는 호출되는 곳을 기준으로 외부 변수에 접근할까요?


*/





/* -------------------- */
/* 클로저(Closures)       */
/* -------------------- */

// 클로저 (closure) 란?
// - JavaScript의 매우 강력한 특성으로 독립적인 변수를 참조하는 함수를 말합니다.
//   즉, 클로저에 정의된 함수는 그것이 작성된 환경을 '기억'합니다.


// 전역오염을 시키지 않고
// 외부변수에 접근할 수 있는 encaosulation 함수
// 함수 내부에 전달된 변스의 값을 가지고 있기 때문에 return으로 내보낼 수 있다.
// gc 수집 대상이 되지 않는다
// 지워지지 않는 렉시컬 환경을 많이 생성하기 때문에 콜스텍에 부하를 줄 수 는 있다. 그러나 체감은 어렵다.


function sum(a,b){
  return a + b;
}

sum(1,2) //3


const value = sum(1, 2); // 3
// const value= sum; // 함수 본문




// function first(){
//   let x = 10;

//   function second(){
//     let y = 20;

//     return x + y;
    
//   }

//   return second

// }

// // first()() // 커링펑션 출력:30 개념만!!

// const a = first();
// // a() // 출력:30 함수가 함수를 리턴했을때 안쪽함수가 밖함수를 참조했을때 클로저,
// // 원래 함수는 데이터를 기억못해서 오브젝트를 썼는데, 이제 함수도 클로저를 이용해 데이터를 기억할 수 있게 됨.




function first(x){
  // let x = 10;

  function second(y){
    // let y = 20;

    return x + y;
    
  }

  return second

}


// const a = first(10); //30


// const a = first(10);





function multi(x){
  function inner(y){
    return x * y
  }
  return inner
}


const double = multi(2);
const triple = multi(3);





function counter(){
  let count = 0;

  function inner(){
    return ++count;
  }

  return inner
}


const c1 = counter();
const c2 = counter();
const c3 = counter();



const _counter = () =>{
  let count = 0;
  
  return ()=> ++count;
}


// 함수의 이름이 없어도 된다 내보내만 진다면... 









// 모든 함수에는 실행 컨텍스트가 있습니다. 실행 컨텍스트는 해당 함수 내의 변수와 
// 해당 부모 환경에 대한 참조를 의미하는 환경으로 구성됩니다. 상위 환경에 대한 참조는 
// 내부 함수가 작성된 범위 외부 또는 내부에서 호출되는지 여부에 관계없이 상위 범위의 
// 모든 변수를 모든 내부 함수에 사용할 수 있게 합니다.
//
// 따라서 함수가 사실상 환경(해당 환경에 정의된 변수)에 대한 참조를 가지고 있기 때문에 
// 함수가 이 환경(또는 영역(scope))을 "기억"하는 것처럼 보입니다!
//
// 모든 실행 컨텍스트에는 어휘 환경(Lexical Environment)이 있습니다. 
// 이 어휘 환경은 식별자 바인딩(즉, 변수 및 관련 값)을 보유하고 있으며 
// 외부 환경에 대한 참조도 가지고 있습니다.
// 
// 각 환경이 접근 할 수 있는 일련의 식별자를 "범위(Scope)"라고 합니다. 
// 이러한 범위를 "스코프 체인(Scope Chain)"을 통해 계층적 환경 체인에 
// 중첩 할 수 있습니다.






// 어느 시점이든 하나의 실행 컨텍스트만 실행 될 수 있습니다.
// 이것이 JavaScript가 "단일 스레드"인 이유입니다.
// 
// 즉, 한 번에 하나의 명령만 처리 할 수 있습니다. 일반적으로 
// 브라우저는 "스택(Stack)"을 사용하여 이 실행 컨텍스트를 유지 관리합니다. 
// 스택은 LIFO(Last In First Out) 데이터 구조입니다. 

//
// 스택에 푸시(push) 한 마지막 것이 가장 먼저 꺼내집니다. 스택의 
// 맨 위에 요소만 삽입하거나 삭제할 수 있기 때문입니다. 현재 또는 
// "실행 중인" 실행 컨텍스트는 항상 스택의 맨 위에 있는 항목입니다. 
//
// 실행 중인 실행 컨텍스트의 코드가 완전히 평가되면 최상위 항목이 
// 팝(pop) 된 다음 실행 항목이 실행 컨텍스트를 실행하는 것으로 
// 간주됩니다.
//
// 또한 실행 컨텍스트가 실행되고 있다고 해서 다른 실행 컨텍스트를 
// 실행하기 전에 실행이 완료되어야한다는 것을 의미하지는 않습니다. 
// 실행 중인 실행 컨텍스트가 일시 중단되고 다른 실행 컨텍스트가 
// 실행 중인 실행 컨텍스트가되는 경우가 있습니다. 
// 
// 일시중단 된 실행 컨텍스트는 나중에 중단 된 부분을 선택합니다. 
// 한 실행 컨텍스트가 이와 같이 다른 컨텍스트로 대체 될 때마다 
// 새 실행 컨텍스트가 만들어져 스택에 푸시되고 현재 실행 컨텍스트가 됩니다.

// [ 실행 컨텍스트 N + 3  ] ⬅︎ 현재 실행 컨텍스트 
// [ 실행 컨텍스트 N + 2  ] 
// [ 실행 컨텍스트 N + 1  ] 
// [ 실행 컨텍스트 N      ] 
// [ 실행 컨텍스트        ] // 글로벌